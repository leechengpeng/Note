## 静态和动态绑定
**绑定**是指程序调用函数时，具体应使用哪个代码块由编译器决定。以重载为例，C++编译器根据传递的参数和函数名决定具体应该调用哪一个函数，这个过程称为绑定：
* **静态绑定**：编译器在**编译过程**完成绑定
* **动态绑定**：编译器在程序**运行过程**完成绑定

## C++构造函数为什么不能是虚函数？
* **继承的角度**：假如子类A继承B，它们的构造函数是虚函数，此时会产生一个悖论：`正常构造顺序B() A()，但子类A的构造函数是虚函数，因此在构造子类A的时候，只会调用子类的构造函数。`
* **设计角度**：虚函数对应一个虚函数表，对象通过虚函数表来找到对应的虚函数，但虚函数表是在类调用构造函数的时候创建的。因此如果构造函数是虚函数，这个时候根本没有虚函数表。

## 避免在构造函数中调用虚函数
* 在构造函数中调用虚函数，代码可以正常编译和执行，但其虚函数行为异常（不会产生多态行为）
* 基类调用虚函数，只会执行基类的虚函数而不会执行子类的虚函数，因为在构造基类的时候，基类只能得到基类的虚函数表

## 避免在析构函数中调用虚函数
同上

## dynamic_cast
* **dynamic_cast**转换的时候涉及运行时类型检查，也就是RTTI
* **dynamic_cast**转换的类型必须有虚函数才能进行转换，没有虚函数就没有虚函数表，会产生编译错误
* **dynamic_cast**向上转型类似于**static_cast**，向下转型可能转型失败，返回为空
* **dynamic_cast**转换失败：指针返回NULL，引用抛出**bad_cast**

## 不能在析构函数中抛出异常
* **语法上**可以在析构函数中抛出异常，C++没有禁止析构函数抛出异常
* 析构函数被调用的情况：
    * **对象正常生命周期结束调用**：可以正常捕获异常，无太大影响
    * **异常发生时从函数堆栈清理时调用**：如果发生异常，然后C++机制再调用析构函数的异常，会导致程序崩溃
    * **无法正常释放资源**：析构函数异常点后面的释放资源动作不会被调用

## STL迭代器类型
* **input迭代器**：从容器读取元素，迭代器每次只能向前移动一位，也就是说一个迭代器只能遍历一遍迭代器
* **output迭代器**：像容器写入元素，同input迭代器
* **forward迭代器**：组合input和output迭代器
* **bidirectional迭代器**：可以双向访问
* **random acess迭代器**：可以任意跳跃

## 字节顺序
字节存储机制主要有两种：
* **大端模式**：低位存放在**高地址**中。符号位为第一个字符，容易判断正负。
* **小端模式（顺序）**：低位存放在**低地址**中。排列方式都一样，容易类型转换。

比如十六进制数字`0x01020304`存放方式：

|类型|0x00ff3304|0x00ff3303|0x00ff3302|0x00ff3301|
|---|---|---|---|---|
|大端|04（低位）|03|02|01|
|小端|01|02|03|04（低位）|

**网络字节顺序（大端）**：按高位到低位顺序存储

**主机字节顺序**：由具体主机确定

## 栈溢出的原因及解决办法
栈的大小一般默认为1M左右，导致栈溢出的常见原因有两个：
* 函数调用层次过深，每调用一次就压一次栈
* 局部变量占用空间太大，如：申请`char array[1024*1024];`失败，但`char array[1024*1000];`成功

解决方法：
* 增加栈内存（ulimit -s 32768）
* 使用堆

### C++的内存分区
* **栈区**：主要存放**函数参数**以及**局部变量**，由系统自动分配释放（栈一般默认大小为1M，参考3）。
* **堆区**：用户分配，通常调用malloc/new手动申请，手动释放
* **全局/静态区**：存放**全局变量、静态变量**，程序结束后由系统释放
* **字符串常量区**：存放**字符串常量**，程序结束后由系统释放
* **代码区**：存放程序的二进制代码

## C++重写（overwrite）
**overwrite**指派生类的函数名**屏蔽**与其同名的基类函数，规则如下：
* 派生类的函数与基类**函数同名**，**参数不同**：派生类函数无论有无**virtual**关键字都会**屏蔽基类同名函数**
* 派生类的函数与基类**函数同名**，**参数相同**：基类函数没有**virtual**（如果有：override），**屏蔽基类同名函数**

## 构造函数和析构函数调用顺序
* **构造函数**：优先调用**基类**构造函数，然后再调用**子类构造函数**
* **析构函数**：与**构造函数**相反

## 其他 
1. static，修饰变量，使之具有全局变量的特性，也不会破坏变量的访问范围（局部访问）
2. inline是为了取代宏定义（只是简单替换，不涉及类型检查）而出现的，继承了宏定义快速的有点，同时也保证参数的检测
3. 前置声明：解决**交叉引用**问题，加快编译速度（不需要再引用头文件）。


