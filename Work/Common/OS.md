# 操作系统
## 1. 进程
### 1.1 进程的基本定义
> 程序一次执行的实例，操作系统**资源分配**的基本单位。

程序只是指令的集合，而进程才是程序的真正执行，同一个程序可以产生多个进程。进程所需资源有：CPU时间片、存储、文件和I/O设备等。

### 1.2 进程的状态
1. **运行态**：进程正在CPU上运行。
2. **就绪态**：获得了除CPU资源外的其他所有资源，一旦获得CPU资源即变为**运行态**。
3. **阻塞态**：又称**等待态**，进程正在等待某一事件的发生。比如，等待某一资源（不包括CPU）可用或等待输入/输出完成。**即使CPU空闲，该进程也不能执行**。
4. **创建态**：进程正在被创建，尚未转到就绪态。
5. **结束态**：进程正常或中断接收。

![进程状态切换](https://github.com/leechengpeng/Note/blob/master/Resources/Images/process_status.png)

注意：
* **阻塞态**是不能直接切换到**运行态**，阻塞态必须等待所需资源就绪（就绪态）才能被执行。
* **运行态**因为进程时间片到或者优先级更高级的进程而变为**就绪态**。

## 2. 线程
> 轻量级的进程，包括线程ID、寄存器集合和堆栈（线程拥有独立的堆栈）等。

线程共享进程环境包括：
1. **进程代码段**
2. **进程公有数据**：全局变量，线程可以利用公有数据进行通信
3. **进程文件描述符**
4. **线程共享进程堆区**

## 3. 进程和线程
* 进程是**资源分配**的基本单位，线程是**调度**的基本单位
* 进程因创建和销毁都需要分配和销毁资源，因此进程切换开销远大于线程切换的开销。线程切换只需要保存少量寄存器状态。
* 进程间通信需要借助操作系统，而线程可以直接读写进程数据段。

## 4. 进程同步
很多系统资源在同一时间只能被一个进程使用（临界资源），这个时候就需要使用同步来保证资源的正常使用，进程同步机制有四种：
1. **临界区（Critical Section）**：访问临界资源的那段代码被称为**临界区**，临界区只能用于同步进程内的线程，而**互斥量**、**信号量**和**事件**可用于进程间的线程同步。
2. **互斥量（Mutex）**：只有拥有**互斥对象**线程才能访问公共资源。因为互斥对象唯一，因此保证公共资源不会同时被多个线程访问。

> 临界区是非内核对象，在用户态进行锁操作，速度快；互斥量是内核对象，在内核进行所操作，速度慢。

3. **信号量（Semaphore）**：它允许多个线程同一时刻访问同一资源，但限制同时访问该资源的最大数量。
4. **事件（Event）**：通过通知操作的方式保持线程的同步，还可以方便实现对多个线程的优先级比较。

## 5. 进程通信
* **管道和有名管道**：数据只能单向流动，管道用于有亲缘关系的进程通信，有名管道可用于无亲缘关系的进程通信
* **套接字**：用于不同终端之间的进程进行通信
* **信号量**：信号量允许多个进程对共享资源进行访问，因此可以用来进行进程间通信
* **共享内存**：共享内存由一个进程创建，多个进程都可以访问
* **消息队列**：消息队列是有消息的链表，存放在内核中并由消息队列标识符标识。消息队列解决了**信息量承载信息量少**和**管道无格式字节流/缓冲区大小受限**的问题

## 6. 调度算法


## 7. 死锁
* **死锁**：一个进程集合中的多个进程因资源竞争而造成互相等待的现象
* **死锁必要条件**：
    - 互斥条件：资源不能被共享，只能由一个进程使用
    - 请求和保持条件：已得到资源的进程可以再次申请新的资源
    - 非剥夺条件：已经分配的资源不能从相应的进程中被强制剥夺
    - 循环等待条件：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源
* **死锁处理策略**：
    - 忽略该问题，如window进程管理器直接关闭该进程
    - 检测死锁并回复
    - 通过对资源有序分配，避免环路发生
    - 破坏死锁必要条件，来预防死锁的产生

## 8. 系统调用和库函数的区别？
* **系统调用**：操作系统为程序与硬件设备进行交互而专门提供的接口，发生在内核空间。
* **库函数**：将一些常用的函数编写完后放到一个文件中，发生在用户空间。

因为不同操作系统的系统实现不一样，因此移植性较差。同时，系统调用需要切换内核空间，因此开销较大。

## 9. 守护、僵尸、孤儿进程的概念
* **守护进程**：运行在后台的一种特殊进程，独立于控制终端并周期性地执行某些任务。
* **僵尸进程**：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程（危害：如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免）。
* **孤儿进程**：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作（init进程就会代表党和政府出面处理它的一切善后工作，因此孤儿进程并不会有什么危害）。

## 10. select和epoll
**select**和**epoll**都来实现**I/O多路复用技术**的Linux接口，**I/O多路复用技术**是指：
> 当系统中某个I/O可用时，内核会通知相应进程该I/O可用，从而进程不会因为等待I/O操作而阻塞。

相比**多线程技术**，**I/O多路复用技术**因为不必维护多线程状态从而系统开销较小。

### 10.1 select和epoll区别
1. **select**采用**轮询策略**，**epoll**采用**触发式策略**。由于策略的不同，**select**会IO效率随FD数目增加而线性下降，而**epoll**不会。
2. **select**的数量受限于最大文件描述符（1024），而epoll的数量几乎无限。
### 10.2 select和epoll及多线程使用场景
* **select和epoll使用场景**：客户端连接量大，但是每个客户端发送的数据量少，并且向服务器发送消息的次数很少。
* **多线程使用场景**：客户端连接量小，每个客户端发送的数据量大，且长时间连接发送消息。

## 11. 内存屏障
> 由于编译器的优化和缓存的使用，导致对内存的写入操作不能及时的反应出来，也就是说当完成对内存的写入操作之后，读取出来的可能是旧的内容。

内存屏障的分类：
* **编译器引起的内存屏障**
* **缓存引起的内存屏障**
* **乱序执行引起的内存屏障**

相关链接：[http://www.cnblogs.com/duyy/p/3721132.html](http://www.cnblogs.com/duyy/p/3721132.html)

### Linux
* **Shell**分为**内部命令**（exit、cd等）和**外部命令**（可执行程序，ls、vi等），外部命令通常存放在`/bin`、`/usr/bin`等目录下。
* **grep命令**：是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来，命令格式`grep [pattern] file`。
* **文件权限**：**owner/group/others**，**r-4、w-2、x-1**。
* **文件**：**普通文件、目录文件、链接文件和设备文件**
* **文件描述符**：内核利用**文件描述符**来访问**文件**，文件描述符为非负整数。打开或者新建文件时，内核都会为这些文件分配文件描述符。通常文件描述符的前三个为**标准输入0、标准输出1和标准错误2**。
* **文件描述符对性能的影响**：文件描述符的上限默认为1024，如果对繁忙的web服务器，肯能导致文件描述符不够用而导致无法访问新的文件。可以通过`ulimit`命令临时或`/etc/security/nf`配置文件永久增加文件描述符数量。
