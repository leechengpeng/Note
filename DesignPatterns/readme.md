# 设计模式

## 设计模式设计原则
### 1. 单一职责原则（Single Responsibility Principle, SRP）
接口一定要做到单一职责，类的设计尽量做到**只有一个原因或因素引起变化**。

### 2. 里氏替换原则（Liskov Substitution Principle, LSP）
继承是非常优秀的面向对象语言机制，有诸多优点：**提高代码的重用性、可扩展性（开放性）**。但继承也有很多缺点，如子类必须继承所有基类的方法，增强了代码的耦合性等。**里氏替换原则**就是一个用来规范继承的原则，从而使之利大于弊，其定义如下：
> **引用基类的任何地方都可以替换成子类，而不引起任何错误或异常。**

**里氏替换原则**为继承定义了一个良好的规范，上述的定义包含以下3层含义：
* **子类必须完全实现基类的方法**。
* **在设计函数接口时，通常会将抽象类（基类）作为函数参数传入，如果不能这样做，说明已经违背了LSP**。
* **如果子类不能完整的实现基类的方法，说明父类的某些方法已经在父类发生“畸变”，此时应该将当前继承关系断开**。

如果不符合**LSP**原则，建议避免使用继承或则重新设计继承结构。

### 3. 依赖倒置原则（Dependence Inversion Principle, DIP）
**依赖倒置原则**就是**模块（类）设计依赖于抽象（抽象类/接口），不依赖于细节（实现类，实现接口或者继承抽象类而产生类的细节）**。简而言之，就是面向接口编程，当需要增加新的功能时，只需要继承抽象，而不变动原有代码。抽象是对实现的一种约束，约束具体实现细节。**DIP**能够有效降低类之间的**耦合性**，提高系统稳定性，降低并行开发（先接口设计，不会导致团队开发阻塞）引起的风险，提高代码的可读性和可维护性。

抽象依赖的3中写法：
* 构造函数注入抽象依赖
```C++
class Driver
{
public:
    Driver(Car car);
};
```
* Set方法注入抽象依赖
```C++
class Driver
{
public:
    void setCar(Car car);
};
```
* 接口注入抽象依赖
```C++
class Driver
{
public:
    void driveCar(Car car); // 即使用抽象依赖的接口部分
};
```

### 4. 开闭原则
对扩展开放，对修改关闭。

### 5. 接口隔离原则
接口隔离原则定义：
* 客户端不应该依赖其不需要的接口，接口表示**Class**或**Interface**
* 类之间的依赖关系应建立在最小接口之上

**隔离**的含义就是接口职责单一（负责自己的职责），其规范了一下几点设计原则：
* 接口设计应该尽量的小（职责单一），但却有一定限度，不应该太小而导致系统过于复杂难以维护
* 接口要高内聚（提高类的处理能力，减少对外交互），简而言之，尽量少的提供**public**方法，减少对外“承诺”

### 6. 迪米特法则
**迪米特法则**也叫**最小知识原则**，其描述**一个对象应该对其他对象有最少的了解**。通俗地讲，一个类对自己需要耦合或调用的类知道得最小，只需要了解其**public**方法，不需要了解其细节实现，也一定程度上的要求一个类尽量少提供**public**方法。

### 7. 类的设计
在类的设计过程中，应有以下考虑流程：
1. 类本身职责应该尽量的单一（单一职责原则、接口隔离原则）
2. 类需要高内聚，尽量少的提供类的**public**方法（接口隔离原则、迪米特法则）
3. 类所依赖的其它类，需通过其它类的基类传入（依赖倒置原则），其该基类能被其可能传入的子类完全替代（里氏替换原则）
4. 类所提供的每一个接口（方法），职责都应该尽量单一（单一职责原则）
5. 类在调用其它类所提供的接口（方法）时，应尽量避免太过了解其它类的细节（迪米特法则）

## 23种设计模式
| 创建类设计模式 | 行为类设计模式 | 结构类设计模式 |
| --- | --- | --- |
| [单例模式](singleton.md)、[工厂模式](factory.md) | [责任链模式](chain.md)、[策略模式](strategy.md)、[模板方法模式](template.md) | [装饰模式](decorator.md) |
