# 一些简单的算法题

## 1. 链表
* **如何访问单向链表倒数第n个元素**：设置两个指针：指针P指向第一个元素，指针B指向距离指针P的第n个元素，指针P和B同时往链表尾部移动。当B移动到链表末尾时，指针P指向的位置即使链表倒数的第n个元素。

* **判断两个无环链表是否相交**：只需判断两个链表**尾部是否相同**即可（还有一个比较笨的方法，建立链表一的地址哈希表，然后再将链表二的地址与哈希表中的地址对比，看哈希表中是否存在）。

* **寻找两个无环链表相交的起点**：首先将两个链表都遍历一遍，得到两链表的长度M和N。假设`M - N = X`（M为较长的一个链表），首先让较长的链表M先移动X次，然后再同时遍历两个链表，分别比较其结点是否相交。 

* **判断单链表是否有环**：设定一个快指针（每次走两步），一个慢指针（每次走一步），如果是有环，则两个指针一定会相遇。

* **判断单链表是环的起点**：根据一系列数据推断，在链表头部设置一个指针，上述相交点设置一个指针，同时一步一步移动，它们相遇的时候即是起点。

## 2. 两个整数集合A和B，求它们的交集
1. 将集合A中的整数存放到map中，且每个整数对应的值为1
2. 再读取集合B中的值，判断集合的值是否已经存在map中，如果存在则表示该值属于交集

## 3. 统计论坛在线人数，注册用户有两亿个，每个用户的登录时间和退出时间都会存放在日志中，颗粒度为秒（哈希）
1. 将天转换为颗粒度秒：3600 * 24 = 86400s
2. 定义一个数组Delta[86400]，每个元素表示**当前这一秒**的**人数变化值（人数变化可能为负）**：读取日志数据，将每位用户登录对应的时间点加1，退出对应的时间点减1
3. 定义另外一个数组OnlineNum[86400]，每个元素表示当前这一秒在线人数：`OnlineNum[0] = Delta[0], OnlineNum[1] = OnlineNum[0] + Delta[1]` -> `OnlineNum[n] = OnlineNum[n-1] + Delta[n]`

## 4. C++中当指针加上什么的时候和引用一样？加上const，都表示对目标位置的引用且不能改变引用的对象，但其本质却不一样

## 5. 有大量无符号（unsigned int）乱序整数集（40亿），如何快速判断一个数是否存在？（哈希）
1. **unsigned int**取值范围为[0, 2^32 - 1]，申请2^32 / 8 = 512M内存（即：`bit Array[2^32]`），用**每一位**表示一个对应的数值
2. 遍历这40亿个数，每一个树对应的bit位就置位
3. 查询时，直接看当前这一位是否被置位即可判断其是否存在

## 6. 
