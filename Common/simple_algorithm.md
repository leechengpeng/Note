# 一些简单的算法题

### 1. 链表
* **在O(1)时间内删除一个单向链表的某一个节点X**：将**节点X**的后面一个**节点Y**复制到节点X上，然后删除**节点Y**
* **如何访问单向链表倒数第n个元素**：设置两个指针：指针P指向第一个元素，指针B指向距离指针P的第n个元素，指针P和B同时往链表尾部移动。当B移动到链表末尾时，指针P指向的位置即使链表倒数的第n个元素。

* **判断两个无环链表是否相交**：只需判断两个链表**尾部是否相同**即可（还有一个比较笨的方法，建立链表一的地址哈希表，然后再将链表二的地址与哈希表中的地址对比，看哈希表中是否存在）。

* **寻找两个无环链表相交的起点**：首先将两个链表都遍历一遍，得到两链表的长度M和N。假设`M - N = X`（M为较长的一个链表），首先让较长的链表M先移动X次，然后再同时遍历两个链表，分别比较其结点是否相交。 

* **判断单链表是否有环**：设定一个快指针（每次走两步），一个慢指针（每次走一步），如果是有环，则两个指针一定会相遇。

* **判断单链表是环的起点**：根据一系列数据推断，在链表头部设置一个指针，上述相交点设置一个指针，同时一步一步移动，它们相遇的时候即是起点。

* **删除链表的重复项**：使用**hash_map**，从前到后遍历链表：1. 如果hash_map中已存在该元素值，则删除当前节点；2. 如果hash_map不存在该元素值，则项hash_map添加该项，并继续遍历。

### 2. 两个整数集合A和B，求它们的交集
1. 将集合A中的整数存放到map中，且每个整数对应的值为1
2. 再读取集合B中的值，判断集合的值是否已经存在map中，如果存在则表示该值属于交集

### 3. 统计论坛在线人数，注册用户有两亿个，每个用户的登录时间和退出时间都会存放在日志中，颗粒度为秒（哈希）
1. 将天转换为颗粒度秒：3600 * 24 = 86400s
2. 定义一个数组Delta[86400]，每个元素表示**当前这一秒**的**人数变化值（人数变化可能为负）**：读取日志数据，将每位用户登录对应的时间点加1，退出对应的时间点减1
3. 定义另外一个数组OnlineNum[86400]，每个元素表示当前这一秒在线人数：`OnlineNum[0] = Delta[0], OnlineNum[1] = OnlineNum[0] + Delta[1]` -> `OnlineNum[n] = OnlineNum[n-1] + Delta[n]`

### 4. C++中当指针加上什么的时候和引用一样？加上const，都表示对目标位置的引用且不能改变引用的对象，但其本质却不一样

### 5. 有大量无符号（unsigned int）乱序整数集（40亿），如何快速判断一个数是否存在？（哈希）
1. **unsigned int**取值范围为[0, 2^32 - 1]，申请2^32 / 8 = 512M内存（即：`bit Array[2^32]`），用**每一位**表示一个对应的数值
2. 遍历这40亿个数，每一个树对应的bit位就置位
3. 查询时，直接看当前这一位是否被置位即可判断其是否存在

### 6. 在大量（100W）数字中找出前面最大的100个数
设计一种数据结构（最小值堆），保存当前最大的100个数，数据结构应满足：
1. 得到当前最小的树
2. 将最小数替换后，重新调整数据结构

### 7. 找出数组中出现次数超过一半的数：hash_map

### 8. 寻找和为定值的两个数：输入一个整数数组和一个整数X，在数组中查询一对数M和N，使`X = M + N`
1. hash_map（空间换时间）：将数组散列到hash_map中，逐个遍历hash_map，然后用X减去遍历的元素值，再判断map中是否有这个值
2. 排序两端向中间对比

